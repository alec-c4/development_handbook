# Разработка с использованием PostgreSQL

## Общие положения

В качестве основной БД в компании используется PostgreSQL. PostgreSQL - это мощная объектно-реляционная система управления базами данных с открытым исходным кодом, отличающаяся расширяемостью и соответствием стандартам SQL.

## Плагины и расширения

При необходимости используются следующие плагины и расширения:

## Плагины и расширения

При необходимости используются следующие плагины и расширения:

| **Название**       | **Решаемая задача**                                                | **Ссылка на репозитарий**                                       |
| ------------------ | ------------------------------------------------------------------ | --------------------------------------------------------------- |
| uuid-ossp          | UUID-индексы                                                       | <https://www.postgresql.org/docs/current/uuid-ossp.html>        |
| pgcrypto           | Криптографические функции, хеширование, шифрование                 | <https://www.postgresql.org/docs/current/pgcrypto.html>         |
| postgis            | Геоинформационная система, пространственные данные                 | <https://postgis.net/>                                          |
| pgvector           | Векторные операции, поиск по сходству для AI/ML                    | <https://github.com/pgvector/pgvector>                          |
| pgvectorscale      | Высокопроизводительный поиск по векторам для LLM                   | <https://github.com/timescale/pgvectorscale/>                   |
| pg_stat_statements | Анализ производительности запросов                                 | <https://www.postgresql.org/docs/current/pgstatstatements.html> |
| pg_trgm            | Поиск по схожести текста                                           | <https://www.postgresql.org/docs/current/pgtrgm.html>           |
| ltree              | Иерархические структуры                                            | <https://www.postgresql.org/docs/current/ltree.html>            |
| pgrouting          | Геопространственная маршрутизация                                  | <https://pgrouting.org/>                                        |
| pg_partman         | Управление партициями таблиц                                       | <https://github.com/pgpartman/pg_partman>                       |
| hypopg             | Гипотетические индексы для планирования запросов                   | <https://github.com/HypoPG/hypopg>                              |
| pg_repack          | Перестроение таблиц без блокировок                                 | <https://github.com/reorg/pg_repack>                            |
| rum                | Индекс для полнотекстового поиска с улучшенной производительностью | <https://github.com/postgrespro/rum>                            |
| pg_cron            | Планировщик заданий в PostgreSQL                                   | <https://github.com/citusdata/pg_cron>                          |
| pg_qualstats       | Анализ предикатов запросов для оптимизации индексов                | <https://github.com/powa-team/pg_qualstats>                     |
| timescaledb        | Решение для временных рядов данных                                 | <https://github.com/timescale/timescaledb>                      |
| pg_hint_plan       | Управление планом выполнения запросов                              | <https://github.com/ossc-db/pg_hint_plan>                       |
| postgres_fdw       | Доступ к внешним таблицам из других баз PostgreSQL                 | <https://www.postgresql.org/docs/current/postgres-fdw.html>     |
| pg_stat_monitor    | Расширенный мониторинг производительности                          | <https://github.com/percona/pg_stat_monitor>                    |

## Основные требования

1. Идентификаторы в БД должны быть в формате UUID
2. Регулярно должна проводиться проверка на упущенные индексы
3. Должен использоваться APM для обнаружения N+1, тяжёлых запросов в БД и других проблем
4. **Применять** миграции для управления схемой базы данных
5. Все таблицы должны иметь первичный ключ
6. Все внешние ключи должны быть проиндексированы
7. Все запросы должны выполняться через параметризованные запросы для предотвращения SQL-инъекций
8. Использовать транзакции для обеспечения атомарности операций
9. Чувствительные данные должны храниться в зашифрованном виде

## Наименование объектов базы данных

1. Все имена таблиц должны быть во множественном числе и в snake_case: `users`, `product_categories`
2. Поля таблиц именуются в единственном числе и в snake_case: `user_id`, `first_name`
3. Индексы должны следовать соглашению: `idx_{table_name}_{column_name(s)}`
4. Внешние ключи: `fk_{table_name}_{referenced_table_name}`
5. Уникальные ограничения: `uq_{table_name}_{column_name(s)}`
6. Первичные ключи: `pk_{table_name}`
7. Проверочные ограничения: `ck_{table_name}_{check_description}`
8. Последовательности: `seq_{table_name}`
9. Триггеры: `trg_{action}_{table_name}`
10. Функции: `fn_{functional_description}`

## Структура таблиц

1. Все таблицы должны включать стандартные поля для аудита:
   - `id` - первичный ключ, UUID
   - `created_at` - timestamp с часовым поясом, метка времени создания записи
   - `updated_at` - timestamp с часовым поясом, метка времени последнего обновления
   - `deleted_at` - timestamp с часовым поясом, NULL для активных записей (soft delete)
2. Для реализации soft delete использовать поле `deleted_at` вместо флага `is_deleted`
3. Версионирование данных (при необходимости) реализуется через отдельные таблицы истории изменений
4. Использовать подходящие типы данных:
   - Для идентификаторов: UUID
   - Для текста: TEXT (не VARCHAR, если нет явной причины для ограничения)
   - Для дат и времени: TIMESTAMP WITH TIME ZONE
   - Для денежных значений: NUMERIC(19,4)
   - Для перечислений: использовать тип ENUM

## Индексирование

1. Обязательно индексировать:
   - Внешние ключи
   - Поля, используемые в условиях WHERE
   - Поля, используемые для сортировки (ORDER BY)
   - Поля, используемые для соединений (JOIN)
2. Проводить регулярный анализ использования индексов с помощью pg_stat_statements и pg_stat_user_indexes
3. Использовать частичные индексы для больших таблиц, где запросы фильтруют по определенным значениям
4. Использовать составные индексы для запросов, фильтрующих по нескольким полям одновременно
5. Использовать функциональные индексы для запросов с функциями в условиях WHERE
6. Регулярно выполнять ANALYZE для обновления статистики таблиц

## Оптимизация запросов

1. Избегать конструкций N+1 при выборке связанных данных
2. Использовать EXPLAIN и EXPLAIN ANALYZE для анализа планов выполнения запросов
3. Оптимизировать запросы для минимизации числа сканируемых строк
4. Использовать подходящие соединения (INNER JOIN, LEFT JOIN и т.д.)
5. Избегать использования SELECT \* - явно указывать необходимые поля
6. Использовать CTE (WITH) для улучшения читаемости сложных запросов
7. Применять оконные функции (OVER, PARTITION BY) вместо GROUP BY, где это улучшает производительность
8. Избегать вложенных коррелированных подзапросов
9. Использовать подходящие условия фильтрации в WHERE для максимального использования индексов
10. Ограничивать количество возвращаемых строк с помощью LIMIT

## Миграции

1. Все изменения схемы базы данных должны выполняться через миграции
2. Каждая миграция должна быть идемпотентной (безопасной для повторного выполнения)
3. Миграции должны содержать как прямой (up), так и обратный (down) скрипты
4. Имена файлов миграций должны содержать последовательный номер и краткое описание: `001_create_users_table.sql`
5. Миграции должны быть атомарными - решать одну задачу
6. Избегать изменений данных в миграциях схемы - разделять миграции схемы и данных
7. Проводить тестирование миграций на тестовой среде перед применением в продакшн
8. Хранить миграции в репозитории вместе с кодом

## Партиционирование

1. Для больших таблиц использовать декларативное партиционирование (PostgreSQL 10+)
2. Выбирать стратегию партиционирования на основе паттернов доступа:
   - RANGE - для хронологических данных
   - LIST - для категориальных данных
   - HASH - для равномерного распределения
3. Создавать партиции заранее для ожидаемых будущих данных
4. Настраивать автоматическое создание партиций при необходимости
5. Регулярно архивировать и удалять устаревшие партиции

## Мониторинг и производительность

1. Настроить мониторинг:
   - Размера базы данных и таблиц
   - Длительности запросов
   - Использования индексов
   - Блокировок
   - Активности вакуума
2. Регулярно выполнять VACUUM и ANALYZE для поддержания производительности
3. Использовать VACUUM FULL для полной перезаписи таблицы (только во время обслуживания)
4. Настроить автоматический vacuum для предотвращения проблем с bloat
5. Мониторить количество и размер dead tuples
6. Настроить оповещения о медленных запросах

## Безопасность

1. Использовать разные роли для разных типов доступа
2. Применять принцип наименьших привилегий
3. Хранить чувствительные данные в зашифрованном виде (pgcrypto)
4. Ограничивать доступ к базе данных сетевыми правилами
5. Аудировать действия пользователей
6. Регулярно обновлять PostgreSQL до последней стабильной версии
7. Настроить SSL для шифрования соединений
8. Не использовать пользователя postgres для приложений

## Резервное копирование и восстановление

1. Настроить регулярные полные и инкрементальные бэкапы
2. Тестировать восстановление из бэкапов
3. Хранить бэкапы в географически распределенных локациях
4. Настроить архивацию WAL для point-in-time recovery
5. Документировать процедуры восстановления
6. Настроить мониторинг процесса резервного копирования

## Высокая доступность и масштабирование

1. Настроить репликацию для высокой доступности
2. Использовать connection pooling (pgBouncer)
3. Настроить автоматическое переключение при отказе
4. Рассмотреть возможность горизонтального масштабирования для аналитических запросов
5. Использовать кэширование для уменьшения нагрузки на базу данных
6. Разделять операционные и аналитические нагрузки
